import { SPLIT_BY } from "./constants";
import { isRgbaValue } from "./typeGuards";

export function getColorValue(value: RGBA | RGB) {
  const { r, g, b } = value;

  const isRgba = isRgbaValue(value);
  if (isRgba && value.a !== 1) {
    const { a } = value;
    return `rgb(${[r, g, b].map((n) => Math.round(n * 255)).join(" ")} / ${(a * 100).toFixed(0)}%)`;
  }

  const toHex = (value: number) => {
    const hex = Math.round(value * 255).toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  };

  const hex = [toHex(r), toHex(g), toHex(b)].join("");
  return `#${hex}`;
}

export function getCssVariableName(
  name: Variable["name"],
  { prefix }: { prefix?: string } = {},
) {
  const splitName = getSplitName(name);
  const prefixString = prefix ? `${prefix}-` : "";
  return `--${prefixString}${splitName.join("-").toLowerCase()}`;
}

export function getCssVariable(
  name: Variable["name"],
  value: string | number | boolean,
  { prefix }: { prefix?: string } = {},
) {
  const variableName = getCssVariableName(name, { prefix });
  const variable = `${getCssVariableName(name, { prefix })}: ${value};`;
  const aliasedVariable = `${variableName}: var(${value});`;

  return {
    aliasedVariable,
    cssVariableName: variableName,
    cssVariable: variable,
  };
}

export function addToThemeObject(
  paths: Array<string>,
  value: string,
  // biome-ignore lint/suspicious/noExplicitAny: TODO
  currentObject: Record<string, any> = {},
): object | string {
  if (paths.length === 0) {
    return `var(${value})`;
  }

  const [currentKey, nextKey, ...remainingKeys] = paths;
  const remainingPaths = paths.slice(1);

  // If the key already exists in the currentObject, merge the new nested object
  // with it.
  // biome-ignore lint/suspicious/noPrototypeBuiltins: suggested `Object.hasOwn()` breaks
  if (currentObject.hasOwnProperty(currentKey)) {
    if (typeof currentObject[currentKey] === "object") {
      currentObject[currentKey] = addToThemeObject(
        remainingPaths,
        value,
        currentObject[currentKey],
      );

      return currentObject;
    }

    // HACK: If the key already exists in the currentObject but the value is a
    // string, this means we have a duplicate key which we're solving by merging
    // the current one with the next one (for instance: if we can already have
    // bg: "#FFF" but another key is bg-subtle, we can't add `subtle` as a
    // nested key so we have to create a new one called "bg-subtle").
    // TODO: Update documentation & add convention guidelines.
    if (typeof currentObject[currentKey] === "string" && nextKey) {
      return Object.assign(currentObject, {
        [`${currentKey}-${nextKey}`]: addToThemeObject(
          remainingKeys,
          value,
          currentObject[`${currentKey}-${nextKey}`],
        ),
      });
    }
  }

  currentObject[currentKey] = addToThemeObject(remainingPaths, value);
  return currentObject;
}

export function generateCssFile(variables: Array<string>) {
  const close = "}\n";
  let cssFile =
    "/* GENERATED BY FIGMA PLUGIN. PLEASE DO NOT MODIFY */\n\n:root {\n  color-scheme: light dark;\n\n";

  // Add variables to file, for both atomic and semantic light variables
  for (const variable of variables) {
    cssFile += `  ${variable}\n`;
  }

  cssFile += close;

  return cssFile;
}

export function generateJsFile(themeObject: object) {
  const jsContent = `/* GENERATED BY FIGMA PLUGIN. PLEASE DO NOT MODIFY */\n\nexport const theme = ${JSON.stringify(
    themeObject,
    null,
    2,
  )} as const;\n`;
  return removeQuotesFromObjectKeys(jsContent);
}

/**
 * Removes quotes from object keys in JSON, except for keys that contain a dash
 * or space.
 */
function removeQuotesFromObjectKeys(jsonString: string) {
  return jsonString.replace(/"([^"-\s]+)":/g, "$1:");
}

export function getSplitName(name: string) {
  return name.toLowerCase().split(SPLIT_BY);
}
